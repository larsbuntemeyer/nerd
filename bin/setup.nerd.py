#!/usr/bin/env python

#FIXME move imports to where they're needed?
import os, sys, string, re, time, shutil, UserDict, types, glob, socket, math

#  ThisIsAClass
#  thisIsAFunction
#  use GVars.out for output, not print
#  use `raise SetupError('blah blah ... error message')` to abort

class SetupError(Exception):
    pass

class EmptyClass:
    pass

def printMemUsageGuess(configInfo, opts):
    SIZEOFDOUBLE = 8 #fixme?
    nvar= configInfo['nvar']
    maxblocks = opts.maxblocks
    nb = [opts.nxb, opts.nyb, opts.nzb]
    for d in range(3):
        if d<opts.dimension: nb[d] = nb[d]+ 2*configInfo['GUARDCELLS']
    ncells = nvar * maxblocks * nb[0] * nb[1] * nb[2]    
    mem = int(math.ceil(SIZEOFDOUBLE*ncells/(1024.*1024)))
    print 'Estimated memory requirement per node: '\
          '%d*%d*%d*%d*%d = = %d cells = %d MB'% \
          (maxblocks, nvar, nb[0], nb[1], nb[2], ncells, mem)
    
def applyNerdStack():
    #we are in object directory
    GVars.out.put('running experimental NerdStack.py on sources in object'\
                  ' directory')
    cmd = os.path.join(GVars.nerdHomeDir, 'tools/scripts/NerdStack.py')
    cmd = cmd + ' patch'
    os.system(cmd)
 
def generateParameterCommentList(modules):
    out = IndentedOutput(4, open('paramFile.txt', 'w'))    
    for mod in modules:
        if not mod['PARAMETER']: continue
        out.put(mod.name)
        out.push()
        
        pars = mod['PARAMETER'].keys()
        pars.sort()
        for par in pars:
            out.put('%s [%s]'% (par, mod['PARAMETER'][par][1]))
            out.push()
            if mod['D'].has_key(par):
                out.put(mod['D'][par])
            out.pop()
        out.pop()
    out.file.close()
        
def generateDbaseDefines(configInfo, opts):
    """ create nerd_defines.fh and dbase_defines.fh"""
    FILE1 = 'dbase_defines.fh'
    FILE2 = 'nerd_defines.fh'

    GVars.out.put('writing ' + FILE1)

    file = open(FILE1, 'w')
    file.write("""#if 0
  File:       dbase_defines.fh, generated by setup script
  
  Contains:   problem dependent parameters, specified at compilation time
  
              Do not edit!  See problem config file.

#endif

"""
               )

    file.write(macroList('#define DBASE_VAR_NAMES',
                         configInfo['variables']))
    
    if configInfo['FLUX']:
        file.write('\n')
        file.write(macroList('#define DBASE_FLUX_NAMES',
                             configInfo['FLUX']))

    if configInfo['PROPERTY']:
        if configInfo['intproperty']:
            file.write('\n')
            file.write(macroList('#define DBASE_PART_INT_PROP_NAMES',
                                 configInfo['intproperty']))
        if configInfo['realproperty']:
            file.write('\n')
            file.write(macroList('#define DBASE_PART_REAL_PROP_NAMES',
                                 configInfo['realproperty']))

    file.write('\n')
    file.write(macroList('#define DBASE_VAR_ADVECT',
                         configInfo['var_advect_str']))
    file.write('\n')
    file.write(macroList('#define DBASE_VAR_RENORM',
                         configInfo['var_renorm_str']))
    file.write('\n')
    file.write(macroList('#define DBASE_VAR_CONSERVE',
                         configInfo['var_conserve_str']))
        
    file.write("""
#define DBASE_NUMBER_OF_ADVECT_VARIABLES %(nvar_advect)d
#define DBASE_NUMBER_OF_RENORM_VARIABLES %(nvar_renorm)d
#define DBASE_NUMBER_OF_CONSERVE_VARIABLES %(nvar_conserve)d
#define DBASE_NUMBER_OF_SPECIES %(NUMSPECIES)d
#define DBASE_NUMBER_OF_MASS_SCALARS %(NUMMASSSCALARS)d
""" % configInfo
               )

    file.close()

    # write global defines file
    GVars.out.put('writing ' + FILE2)
    file = open(FILE2, 'w')
    file.write("""#if 0
File:       nerd-defines.fh, generated by setup script

Contains:   problem dependent parameters, specified at compilation time

Do not edit!  See problem config file.
#endif

#ifndef FLASH_DEFINES_INCLUDED
#define FLASH_DEFINES_INCLUDED

#define FLASH_NUMBER_OF_VARIABLES %(nvar)d
#define FLASH_NUMBER_OF_FLUXES %(nflux)d
#define FLASH_NUMBER_OF_GUARD_CELLS %(GUARDCELLS)d
#define FLASH_NUMBER_OF_INT_PARTICLE_PROPS %(n_int_props)d
#define FLASH_NUMBER_OF_REAL_PARTICLE_PROPS %(n_real_props)d

#define MAX_STRING_LENGTH 80

#define REAL_FORMAT "(ES20.13)"
""" % configInfo)


    if opts.ioConvertBool == 1:
        file.write("#define IOCONVERT\n")
    
    if opts.npg == 1:
        file.write("#define NO_PERMANENT_GUARDCELLS\n\n")
    file.write("#endif\n\n\n")
    file.close()

def generateMakefile(configInfo, opts, machDir):
    TEMPLATE="""#  Makefile for NERD code.  Automatically generated by setup script.
#  Do not edit!

EXE = nerd

default : $(EXE)

#\tMachine-dependent include file

CDEFINES = %(cDefines)s
FDEFINES = %(fDefines)s

#\tprint the compiler flags to file in FLASH/object/
#\t(files name are also hard-coded into source/util/tools/compiler_flags.c)
PRINT_F_FLAGS = $(ECHO) $(FCOMP) $(FFLAGS) $(FDEFINES) > f_compiler_flags
PRINT_C_FLAGS = $(ECHO) $(CCOMP) $(CFLAGS) $(CDEFINES)  > c_compiler_flags
PRINT_LFLAGS = $(ECHO) $(LFLAGS) > loader_flags

include Makefile.h

%(flagRedirect)s

#\tCompile



.SUFFIXES:

.SUFFIXES: .f .F .f90 .F90 .c .C .o
  
.f.o :
\t$(FCOMP) $(FFLAGS) $(FDEFINES) $*.f
.F.o :
\t$(FCOMP) $(FFLAGS) $(FDEFINES) $*.F
.f90.o :
\t$(FCOMP) $(FFLAGS) $(f90FLAGS) $(FDEFINES) $*.f90
.F90.o :
\t$(FCOMP) $(FFLAGS) $(F90FLAGS) $(FDEFINES) $*.F90
.c.o :
\t$(CCOMP) $(CFLAGS) $(CDEFINES) $*.c
.C.o :
\t$(CPPCOMP) $(CFLAGS) $(CDEFINES) $*.C
%%API.c %%API.h %%API-bridges.F90: %%.int
\t./int2API.py $<

.PRECIOUS: %%API.c %%API.h %%API-bridges.F90

# Note, the tmpfiles are needed to ensure that the following routines
# get recompiled every time.  Parallel builds (e.g. gmake -j 4) complicate
# this process, by requiring that the source (e.g. buildstamp.f) is generated
# by the same set of rules (and therefore same process) as the object file

#       Buildstamp routine

#buildstamp.o : .buildstamp_tmpfile
#\t./make_bstamp
#\t$(FCOMP) $(FFLAGS) buildstamp.f
##\t$(RM) buildstamp.f
#\t$(RM) .buildstamp_tmpfile
#
#.buildstamp_tmpfile :
#\ttouch .buildstamp_tmpfile
#
#
##       Release routine
#
#nerd_release.o : .nerd_release_tmpfile
#\t./make_release
#\t$(FCOMP) $(FFLAGS) nerd_release.f
#\t$(RM) nerd_release.f
#\t$(RM) .nerd_release_tmpfile
#
#.nerd_release_tmpfile :
#\ttouch .nerd_release_tmpfile
#
##       Build statistics routine
#
#buildstats.o : .buildstats_tmpfile
#\t$(PRINT_F_FLAGS)
#\t$(PRINT_C_FLAGS)
#\t$(PRINT_LFLAGS)
#\t./make_bstats
#\t$(FCOMP) $(FFLAGS) $(F90FLAGS) buildstats.F90
##\t$(RM) buildstats.F90
#\t$(RM) .buildstats_tmpfile
#
#.buildstats_tmpfile :
#\ttouch .buildstats_tmpfile
#
#
##       NERD  Modules routine
#
#nerdModules.o : 
#\t./make_nerdModules
#\t$(FCOMP) $(FFLAGS) $(F90FLAGS) nerdModules.F90
#\t$(RM) nerdModules.F90


#\tModule Makefiles

%(includeList)s
MODS = \\%(includeMacros)s
       $(MACHOBJ) buildstamp.o nerd_release.o buildstats.o nerdModules.o %(nerd_stack)s

#\tLink

$(EXE) : $(MODS)
\t$(LINK) $(LFLAGS) $(EXE) $(MODS) $(LIB) $(CONFIG_LIB)
\t$(ECHO) SUCCESS

#\tClean up object directory

clean :
\t$(RM) *.o *.a *.mod *API.h *API.c *API-bridges.F90

precision_test : precision_test.o
\t$(LINK) $(LFLAGS) precision_test precision_test.o
"""    
    flagRedirect = setRedirectFlags('Makefile.h', opts.buildFlag,
                                    configInfo['LIBRARY'])

    fDefines = ''
    cDefines = ''
    for define in opts.defines:
        fDefines = fDefines + '$(MDEFS)%s '% define
        cDefines = cDefines + ' ' + define
        
    makefiles = glob.glob('Makefile.*')
    #FIXME remove this once all those makefile dependencies are fixed.
    makefiles.sort()

    if 'Makefile.h' in makefiles: makefiles.remove('Makefile.h')
    includeList = ''
    includeMacros = ''
    for file in makefiles:
        module = os.path.splitext(file)[1][1:]
        includeList = includeList + 'include %s\n'%file
        includeMacros = includeMacros + '\n       $(%s) \\'%module

    nerd_stack = ''
    if opts.nerdStack:
        nerd_stack = 'nerd_stack.o'

    file = open('Makefile', 'w')
    file.write(TEMPLATE%locals())
    file.close()

class outputParameterInfo:
    def write(self):
        f = open(self.rt_initFile, 'w')
        f.write(self.rt_init1 +\
                '\nreturn \nend\n\n\n\nsubroutine get_global_parms'+\
                '\n\nuse runtime_parameters\nuse global_runtime_dec\n\n' +\
                self.rt_init2 +\
                '\nreturn\nend\n')
        f.close()

        f = open(self.rt_declFile, 'w')
        f.write(self.rt_decl+'\n end module global_runtime_dec \n')
        f.close()
        
    def __init__(self, modules):
        """Write info related to Config files' PARAMETERs to various files in
        dir
        """
        self.rt_initFile = 'init_global_parms.F90'
        self.rt_declFile = 'global_runtime_dec.F90'
        self.rt_init2 = ''
        self.rt_init1 = '! Runtime-settable parameter initializations;\n'\
                        '! generated by setup script.\n'\
                        '! Do not edit!\n\n'\
                        'subroutine init_global_parms(parmfile)\n\n'\
                        'use runtime_parameters\n\n'\
                        'character(len=*) :: parmfile\n\n'\
                        'call create_parm_context '\
                        '(global_parm_context)\n'\
                        'call create_global_parms\n'\
                        'call read_parameters (parmfile, '\
                        'global_parm_context)\n'\
                        'call get_global_parms\n'\
                        'return\n'\
                        'end\n\n\n'\
                        'subroutine create_global_parms\n\n'\
                        'use runtime_parameters\n'\
                        'implicit none\n\n'
        
        self.rt_decl = '! Runtime-setable parameter declarations\n'\
                       '! and equivs; generated by setup script.\n'\
                       '! Do not edit!\n\n\n '\
                       ' module global_runtime_dec\n\n' 

        self.checkForDuplicates(modules)        
        self.processModules(modules)
        self.write()



    def checkForDuplicates(self, modules):
        #check that no two parameters have the same name, print warning if
        #they do
        GVars.out.push()
        for mod1 in modules:
            for mod2 in modules:
                if mod1>=mod2: continue
                for p1 in mod1['PARAMETER'].keys():
                    for p2 in mod2['PARAMETER'].keys():
                        if string.lower(p1) == string.lower(p2): #fixme (the lowering should be done at parser level)
                            GVars.out.put('WARNING: Parameter %s defined in'\
                                          ' both\n%s\nand\n%s\nIgnoring'\
                                          ' first instance.\n'%(p1, mod1,
                                                                mod2))
                            #if mod1 and mod2 are parent and child, we want to drop the parent (maybe shouldn't print warning in that case)
                            del mod1['PARAMETER'][p1]
                            
        GVars.out.pop()
                       
    def processModules(self, modules):
        DECLMAP = {'REAL': 'real',
                   'INTEGER': 'integer',
                   'STRING':  'character(len=80)',
                   'BOOLEAN':'logical'}
        
        for mod in modules:
            for pName in mod['PARAMETER'].keys():
                pType, pValue, pConst = mod['PARAMETER'][pName][:]
                if pType=='BOOLEAN': pValue = '.%s.'%pValue

                if pConst:
                    decl = '      %s, parameter :: %s = %s\n'% \
                           (DECLMAP[pType], pName, pValue)
                            
                else:
                    decl = '      %s, save :: %s\n'%(DECLMAP[pType], pName)
                    
                self.rt_decl = self.rt_decl + decl

                if pConst:
                    self.rt_init1= self.rt_init1+\
                           'call add_parm_to_context(global_parm_context,'\
                           ' "%s", %s, %s)\n'%(pName, pValue, "TYPE_CONST")
                else:
                    self.rt_init1= self.rt_init1+\
                           'call add_parm_to_context(global_parm_context,'\
                           ' "%s", %s)\n'%(pName, pValue)

#                self.rt_init2= self.rt_init2+\
#                               'call get_parm_from_context('\
#                               'global_parm_context, "%s", %s)\n'%(pName,
#                                                                   pName)
                
def checkRequirements(modules):
    for mod in modules:
        for req in mod['REQUIRES']:
            good = 0
            for reqmod in req:
                if reqmod in modules:
                    good = 1
            if not good:
                raise SetupError('%s REQUIRES %s, not included'%(mod.name,
                                 string.replace(`req`[1:-1], ',', ' OR')))
                                                                             
def addTopModules(modules, sourceDir='.'):
    """If a top level module isn't in modules, add it, and add it's null
    directory if it has one.

    NOTE: we ignore Config files FIXME (not in documentation)"""
    
    NULLMODULE = 'null'
    topModules = os.listdir(sourceDir)
    for dir in ['CVS', 'sites']:
        if dir in topModules: topModules.remove(dir)
        
    for module in topModules:
        if module not in modules:
            modules.append(NerdModule(module, ignoreConfig=1))
            if os.path.isdir(os.path.join(module, NULLMODULE)):
                modules.append(NerdModule(os.path.join(module, NULLMODULE),
                                           ignoreConfig=1))
    return modules
    
def checkExclusivity(modules):
    #modules contains everybody's parents
    for module in modules:
        for group in module['EXCLUSIVE']:
            #No two elements of group must be in modules
            a=None
            for b in group:
                if b not in modules: continue
                if a: raise SetupError('%s and %s are exclusive'%(a, b))
                a=b
                                     

def checkConflicts(modules):
    for module in modules:
        for group in module['CONFLICTS']:
            for b in group:
                if b in modules:
                    raise SetupError("setup Error: requested module %s"            \
                                     " prohibited by explicit CONFLICTS statement"%(b))
            
        
def readInputModulesFile(file, opts):
    if not os.path.isfile(file):
        raise SetupError('cannot access %s file, try using -auto'%file, 1)

    modules = map(NerdModule, opts.withModules) #redundant if used -auto
                         
    GVars.out.put('scanning %s file for included modules'%file)
    GVars.out.push()
    for line in open(file).readlines():
        rawline = line
        if string.count(line, '#'):
            line=line[:string.find(line, '#')]
        line=string.strip(line)
        if not line: continue
        try:
            a,b=string.split(line)
            if a!='INCLUDE': raise SetupError
        except (ValueError, SetupError):
            raise SetupError('Bad syntax:\n%s'%rawline)

        if b in modules: continue
        modules.append(NerdModule(b))
        GVars.out.put(b)

    GVars.out.pop()
    return modules
 
def stripComments(line, commentCharacter):
    #Strip comments -- FIXME: eats STRINGs
    if string.count(line, commentCharacter):
        line=line[:string.find(line, commentCharacter)]
    return line

def expandDefaultModules(modules):
    new = 1
    while new:
        new = 0
        for module in modules[:]:
            for child in module['DEFAULT']:
                if child not in modules:
                    new = 1
                    modules.append(NerdModule(child))
    return modules

def expandParentModules(modules):
    new = 1
    while new:
        new = 0
        for module in modules[:]:
            parent = module.getParent()
            if (parent and (parent not in modules)):
                    new = 1
                    modules.append(NerdModule(parent))
    return modules

class IndentedOutput:
    def __init__(self, numSpaces=4, file=None):
        self.WRAP = 80
        self.indent = 0
        self.numSpaces = numSpaces
        if not file: self.file = sys.stdout
        else: self.file = file            
    def put(self, text):        
        for line in map(string.strip, string.split(text, '\n')):
            line = ' '*self.indent*self.numSpaces + line
            more = ''
            if len(line)>self.WRAP:
                more = line[self.WRAP:]
                line = line[:self.WRAP]
            self.file.write(line+'\n')
            self.file.flush()
            if more:
                self.put(more)
    def pop(self, numLevs=1):
        """Remove numLevs indentation levels"""
        self.indent = self.indent - numLevs
        if self.indent < 0:
            raise SetupError('Popped indentation one time too many!')
    def push(self, numLevs=1):
        self.indent = self.indent + numLevs

def generateBuildstampGenerator():
    OUTFILE = 'make_bstamp'
    TEMPLATE = """#!/bin/sh -f

#\t\tScript to create a subroutine which writes a 'build stamp'
#\t\tto the log file

rm -f buildstamp.f
echo '      ' subroutine build_stamp \(s_stamp_str, b_stamp_str, str_len\) >> buildstamp.f
echo '      ' implicit none >> buildstamp.f
echo '      ' integer                  :: str_len >> buildstamp.f
echo '      ' character\(len=str_len\) :: s_stamp_str, b_stamp_str >> buildstamp.f
echo '      ' s_stamp_str = \\'%(date)s\\'  >> buildstamp.f
echo '      ' b_stamp_str = \\'`date`\\'  >> buildstamp.f
echo '      ' return >> buildstamp.f
echo '      ' end subroutine >> buildstamp.f
echo '      ' >> buildstamp.f
echo '      ' subroutine system_info \(system_str, str_len\) >> buildstamp.f
echo '      ' integer                  :: str_len >> buildstamp.f
echo '      ' character\(len=str_len\) :: system_str >> buildstamp.f
echo '      ' system_str = >> buildstamp.f
echo '     &' \\'%(uname)s\\'  >> buildstamp.f
echo '      ' return >> buildstamp.f
echo '      ' end subroutine >> buildstamp.f
echo '      ' >> buildstamp.f

"""
    date = time.asctime(time.localtime(time.time()))
    uname = os.uname()
    uname = '%s %s %s %s' % (uname[0], uname[1], uname[2], uname[4])
    file = open(OUTFILE, "w")
    file.write(TEMPLATE%vars())
    file.close()
    os.chmod(OUTFILE, 0744)


def removeParentModules(modules):
    modules = modules[:]
    for module in modules[:]:
        try: modules.remove(module.getParent())
        except ValueError: pass
    return modules

def expandRequiredModules(modules):
    out = modules[:]
    for module in modules:
        for reqs in module['REQUIRES']:
            good = 0
            for req in reqs:
                if req in out:
                    good = 1
            if not good: #pick first module in an OR list
                if GVars.verbose:
                    GVars.out.put('%s wants %s'%(module, reqs[0]))
                out.append(NerdModule(reqs[0]))
    return out
                
def generateModulesfile(outfile, opts):
    GVars.out.push()    
    if os.path.isfile(outfile):
        GVars.out.put('renaming original to Modules.bak')
        os.rename(outfile, 'Modules.bak')

    outfile = open(outfile, 'w')
    outfile.write('#Modules file for %s generated by setup '\
                  '-auto\n\n'%opts.setupName)

    os.chdir('source')
    
    setup=NerdModule(os.path.join('..', 'setups', opts.setupName))
    modules = [setup] + map(NerdModule, opts.withModules)

    while 1:
        oldmodules=modules[:]
        oldmodules.sort()

        modules = expandParentModules(modules)
        modules = expandRequiredModules(modules)
        modules = removeParentModules(modules)
        modules.sort()
        if modules!=oldmodules:
            continue
        modules = expandDefaultModules(modules)
        if modules==oldmodules:
            break
        elif GVars.verbose: 
            GVars.out.put('Expanding defaults:') #ok, we already expanded
            GVars.out.push()
            for mod in modules:
                if mod not in oldmodules:
                    GVars.out.put(`mod`)
            GVars.out.pop()
            
    #We want the Modules file to be concise
    modules = removeParentModules(modules)
    modules.remove(setup)
    
    for module in modules:
        outfile.write('INCLUDE %s\n'%module.name)
    outfile.close()
    
    os.chdir('..')
    GVars.out.pop()


class NerdModule(UserDict.UserDict):
    """Encapsulates module information as expressed in Config files.
    Data is accessed through dictionary methods, ex:

    NerdModule('io/amr')['DEFAULT']
    NerdModule('../setups/sedov')['LIBRARY']

    This is where the Config file syntax is defined.
    NOTE: we need to be in source/ when instantiating this.
    """
    def __init__(self, pathname, ignoreConfig=0):
        UserDict.UserDict.__init__(self)

        self.COMMENT = '#'
        self.FILEBASE = 'Config'

        self.regexps = {}
        self.parsers = []
        
        for name in dir(self.__class__):
            if not re.compile(r'parse[A-Z]+$').match(name): continue
            if type(getattr(self, name))==types.MethodType:
                self.parsers.append(name)
                try: getattr(self, name)('') #initialize regexps, dictionary
                except SetupError: pass


        if not os.path.isdir(pathname):
            raise SetupError('%s is not a valid directory'%pathname)
                        
        self.name = os.path.normpath(pathname) #something like 'io/amr'

        if (not ignoreConfig) and \
           os.path.isfile(os.path.join(self.name, self.FILEBASE)):
            self.filename = os.path.join(self.name, self.FILEBASE)
            self.parse()
        else:
            self.filename = ''

    def __cmp__(self, other):
        """Alphabetical comparison on module names (like 'source/io/amr')"""
        if type(other)==types.StringType:
            return cmp(self.name, other)
        else:
            return cmp(self.name, other.name)

    def __repr__(self):
        return self.name
        
    def getParent(self):
        """Returns parent module's full name, empty string if we're orphans"""
        return os.path.split(self.name)[0] #FIXME ../setups/ case
        
    def initParser(self, keyword, initvalue, regexp=None):
        if self.has_key(keyword): return
        self[keyword]=initvalue
        if regexp:
            self.regexps[keyword]=re.compile(regexp)
            #FIXME solution to STRING PARAMATER hack is to do the comment
            #stripping here by tagging on r'\s*(?:#.*)' to the regexp. No time
            #to test it so I'm not doing it now. This would help with inline
            #comments too.
            
    def match(self, keyword, line):
        match = self.regexps[keyword].match(line)
        if not match:
            raise SetupError('input doesn\'t match regular expression "%s"'%\
                             self.regexps[keyword].pattern)
        return match

    def parse(self):
        lineno = 0

        for line in open(self.filename).readlines():
            lineno = lineno + 1
            rawline = line
            if rawline and rawline[-1]=='\n': rawline = rawline[:-1]

            line=stripComments(line, self.COMMENT)
            line=string.strip(line)
            if not line: continue

            keyword = string.split(line)[0]
            if 'parse'+keyword not in self.parsers:
                raise SetupError('Unknown keyword: file %s, line '\
                                 '%d\n%s'%(self.filename, lineno, rawline))
            try:
                self.rawline = rawline #FIXME this is for STRING PARAM hack
                getattr(self, 'parse'+keyword)(line)
            except SetupError, msg:
                raise SetupError('Bad syntax: file %s, line %d:\n%s\n\n%s' % \
                                 (self.filename, lineno, rawline, str(msg)))

    def parseD(self, line):
        self.initParser('D', {}, 'D\s*(&|\S+)\s*(.*)$')
        key, comment = self.match('D', line).groups()

        if key=='&':
            try:
                self['D'][self.DKey] = self['D'][self.DKey] + ' ' + comment
            except AttributeError:
                raise SetupError('Improper usage of comment continuation')
        else:
            self.DKey = key
            self['D'][key] = comment
            
    def parseVARIABLE(self, line):
        self.initParser('VARIABLE', {},
                        'VARIABLE\s+(\w+)'
                        '(?:\s+((?:NO)?(?:ADVECT|RENORM|CONSERVE)))?'
                        '(?:\s+((?:NO)?(?:ADVECT|RENORM|CONSERVE)))?'
                        '(?:\s+((?:NO)?(?:ADVECT|RENORM|CONSERVE)))?$')
        match = self.match('VARIABLE', line)

        variable = match.group(1)
        if self['VARIABLE'].has_key(variable):
            raise SetupError('VARIABLE %s already declared'%variable)

        attributes = list(match.groups()[1:]) #Generally contains Nones
        attributes.sort()
        self['VARIABLE'][variable] = attributes

    def parseLIBRARY(self, line):
        self.initParser('LIBRARY', [], 'LIBRARY\s+(\S+)$')
        libname = self.match('LIBRARY', line).group(1)

        if libname not in self['LIBRARY']:
            self['LIBRARY'].append(libname)

    def parseGUARDCELLS(self, line):
        self.initParser('GUARDCELLS', None, r'GUARDCELLS\s+([0-9]+)$')
        num = int(self.match('GUARDCELLS', line).group(1))

        if self['GUARDCELLS']!=None:
            raise SetupError('GUARDCELLS already declared')
        self['GUARDCELLS'] = num

    def parseNUMSPECIES(self, line):
        self.initParser('NUMSPECIES', None, r'NUMSPECIES\s+([0-9]+)$')
        num = int(self.match('NUMSPECIES', line).group(1))

        if self['NUMSPECIES']!=None:
            raise SetupError('NUMSPECIES already declared')
        self['NUMSPECIES'] = num

    def parseNUMMASSSCALARS(self, line):
        self.initParser('NUMMASSSCALARS', None, r'NUMMASSSCALARS\s+([0-9]+)$')
        num = int(self.match('NUMMASSSCALARS', line).group(1))

        if self['NUMMASSSCALARS']!=None:
            raise SetupError('NUMMASSSCALARS already declared')
        self['NUMMASSSCALARS'] = num

    def parseFLUX(self, line):
        self.initParser('FLUX', [], r'FLUX\s+(\w+)$')
        flux = self.match('FLUX', line).group(1)

        if flux not in self['FLUX']:
            self['FLUX'].append(flux)

    def parsePROPERTY(self, line):
        self.initParser('PROPERTY', {}, r'PROPERTY\s+(\w+)\s+(INTEGER|REAL)$')
        name, type = self.match('PROPERTY', line).groups()

        if self['PROPERTY'].has_key(name):
            raise SetupError('PROPERTY %s already declared'%name)

        self['PROPERTY'][name] = (type)

    def parseREQUIRES(self, line):
        MAXOR = 10 #FIXME
        self.initParser('REQUIRES', [],
                        r'REQUIRES\s+(\S+)'+MAXOR*r'(?:\s+OR\s+(\S+))?'+'$')
                        
        modules = list(self.match('REQUIRES', line).groups())
        while None in modules: modules.remove(None)
        modules = map(os.path.normpath, modules)

        self['REQUIRES'].append(modules)

    def parsePARAMETER(self, line):
        self.initParser('PARAMETER', {}, r'PARAMETER\s+(\w+)\s+'\
                        '(INTEGER|REAL|STRING|BOOLEAN)\s+'\
                        '(?:(CONSTANT)\s+)?(.+)$')
        name, type, constant, value = self.match('PARAMETER', line).groups()
        if self['PARAMETER'].has_key(name):
            raise SetupError('%s already declared'%name)

        if type=='STRING':
            #This is a hack. I "forgot" to accomodate parsers that would need
            #rawlines when I wrote the general framework. See initParser.
            if not self.regexps.has_key('pstring'):
                self.regexps['pstring']=re.compile(r'PARAMETER\s+(\w+)\s+'\
                                                 'STRING\s+(".*")\s*(?:#.*)?$')
            name, value = self.match('pstring', self.rawline).groups()

        self['PARAMETER'][name]=(type, value, constant)

    def parseDEFAULT(self, line):
        self.initParser('DEFAULT', [], r'DEFAULT\s+(\S+)$')
        module = os.path.normpath(self.match('DEFAULT', line).group(1))
        module = os.path.join(self.name, module)
        
        #A module may define multiple defaults, they all get included
        if module not in self['DEFAULT']:
            self['DEFAULT'].append(module)
                                                
    def parseEXCLUSIVE(self, line):
        self.initParser('EXCLUSIVE', [], r'EXCLUSIVE\s+(.+)$')
        modules = string.split(self.match('EXCLUSIVE', line).group(1))
        modules = map(os.path.normpath, modules)
        modules = map(lambda x, y=self.name: os.path.join(y,x), modules)
        modules.sort()
        
        if modules not in self['EXCLUSIVE']:
            self['EXCLUSIVE'].append(modules)


    def parseCONFLICTS(self, line):
        self.initParser('CONFLICTS', [], r'CONFLICTS\s+(.+)$')
        modules = string.split(self.match('CONFLICTS', line).group(1))
#        modules = map(os.path.normpath, modules)
#        modules = map(lambda x, y=self.name: os.path.join(y,x), modules)
        modules.sort()
        
        if modules not in self['CONFLICTS']:
            self['CONFLICTS'].append(modules)

                        

class ModuleUnion(UserDict.UserDict):
    """Collates info from an ordered list of NerdModule instances"""
    def __init__(self, modules):
        UserDict.UserDict.__init__(self)
        self['FLUX'] = []
        self['VARIABLE'] = {}
        self['LIBRARY'] = []
        self['NUMSPECIES'] = None
        self['NUMMASSSCALARS'] = None
        self['GUARDCELLS'] = None
        self['PROPERTY'] = {}
        
        self.collate(modules)                  
        self.setDefaults()
        self.simplify()

    def collate(self, modules):
        for module in modules:
            for lib in module['LIBRARY']:
                if lib not in self['LIBRARY']:
                    self['LIBRARY'].append(lib) 

            for flux in module['FLUX']:
                if flux not in self['FLUX']:
                    self['FLUX'].append(flux)

            if module['NUMSPECIES']!=None:
                if self['NUMSPECIES']==None:
                    self['NUMSPECIES']=module['NUMSPECIES']
                elif self['NUMSPECIES']!=module['NUMSPECIES']:
                    raise SetupError('NUMSPECIES clash')

            if module['NUMMASSSCALARS']!=None:
                if self['NUMMASSSCALARS']==None:
                    self['NUMMASSSCALARS']=module['NUMMASSSCALARS']
                elif self['NUMMASSSCALARS']!=module['NUMMASSSCALARS']:
                    raise SetupError('NUMMASSSCALARS clash')

            if module['GUARDCELLS']!=None:
                if self['GUARDCELLS']==None:
                    self['GUARDCELLS']=module['GUARDCELLS']
                else:
                    self['GUARDCELLS']= max(module['GUARDCELLS'],
                                            self['GUARDCELLS'])

            for var in module['VARIABLE'].keys():
                if var in self['VARIABLE'].keys():
                    if module['VARIABLE'][var]!=self['VARIABLE'][var]:
                        raise SetupError('VARIABLE mismatch')
                else:
                    self['VARIABLE'][var]=module['VARIABLE'][var]

            for prop in module['PROPERTY'].keys():
                if prop in self['PROPERTY'].keys():
                    if module['PROPERTY'][prop]!=self['PROPERTY'][prop]:
                        raise SetupError('Integer/Real PROPERTY mismatch')
                else:
                    self['PROPERTY'][prop]=module['PROPERTY'][prop]

    def setDefaults(self):
        if self['NUMSPECIES']== None:
            self['NUMSPECIES'] = 1
            GVars.out.put('number of species not specified, using default '\
                          'NUMSPECIES 1')

        if self['NUMMASSSCALARS']== None:
            self['NUMMASSSCALARS'] = 0
            GVars.out.put('number of mass scalars not specified, using default '\
                          'NUMMASSSCALARS 0')

        if self['GUARDCELLS']==None:
            self['GUARDCELLS'] = 4
            GVars.out.put('number of guard cells not specified, using default'\
                          ' GUARDCELLS 4')
            
    def simplify(self):
        """Store stuff that can be computed from Config info in the dictionary
        We'll use lowercase keys to separate things"""
        vars = self['VARIABLE']
        keys = vars.keys()
        #Need this since order in which a dict returns it's keys is not
        #determined.
        self['variables'] = keys

        sum = lambda x, y: x+y

        self['n_int_props']  = 0
        self['n_real_props'] = 0
        self['intproperty']  = []
        self['realproperty'] = []

        for prop in self['PROPERTY'].keys():
            if self['PROPERTY'][prop] == ('INTEGER'):
                self['n_int_props'] = self['n_int_props'] + 1
                self['intproperty'].append(prop)
            else:
                self['n_real_props'] = self['n_real_props'] + 1
                self['realproperty'].append(prop)

        self['nvar'] = self['NUMSPECIES'] + self['NUMMASSSCALARS'] + len(vars)
        self['nflux'] = self['NUMSPECIES'] + self['NUMMASSSCALARS'] + \
                                               len(self['FLUX'])

        #species are assumed to be ADVECT/RENORM/NOCONSERVE
        #mass scalars are assumed to be ADVECT/NORENORM/CONSERVE
        self['nvar_advect'] = self['NUMSPECIES'] + self['NUMMASSSCALARS'] + \
                              reduce(sum, map(lambda x, vars=vars: \
                                              'ADVECT' in vars[x], keys), 0)
        self['nvar_renorm'] = self['NUMSPECIES'] + \
                              reduce(sum, map(lambda x, vars=vars: \
                                              'RENORM' in vars[x], keys), 0)
        self['nvar_conserve'] = self['NUMMASSSCALARS'] + \
                              reduce(sum, map(lambda x, vars=vars: \
                                           'CONSERVE' in vars[x], keys), 0)


        self['var_advect_str'] = `map(lambda x, vars=vars: \
                                      int('ADVECT' in vars[x]),
                                      keys)`[1:-1]
        self['var_renorm_str'] = `map(lambda x, vars=vars: \
                                      int('RENORM' in vars[x]),
                                      keys)`[1:-1]
        self['var_conserve_str'] = `map(lambda x, vars=vars: \
                                        int('CONSERVE' in vars[x]),
                                            keys)`[1:-1]
                                            

def dumpSetupInfo(modules):
    FILE1 = 'setup_call'
    FILE2 = 'setup_mods'
    
    file = open(FILE1, 'w')
    for arg in sys.argv:
        file.write(arg+' ')
    file.write('\n')
    file.close()

    file = open(FILE2, 'w')
    for module in modules:
        file.write(`module`+'\n')
    file.close()
    
def macroList(base, list):
    VAR_PER_DEFINE = 4
    NUM_OF_DEFINES = 12

    vars = string.split(`list`[1:-1])
    vars.reverse()

    out=''
    for i in range(NUM_OF_DEFINES):
        out = out + '%s_%d'%(base, i+1)

        if not i:
            out = out + ' /'

        for j in range(VAR_PER_DEFINE):
            try:
                out = out + ' ' + vars.pop()
                if not vars:
                    out = out + ' /'
                elif j==VAR_PER_DEFINE-1:
                    out = out + ' &'
            except IndexError:
                break

        out = out + '\n'

    return out

def runPreprocessor(flags=''):
    """Run the cpp preprocessor on all source files in current dir"""
    SUFFIXES = ['.f90', '.F90', '.f', '.F']
    ERRORFILE = 'cpperrors.log'
    TEMPFILE = 'preproc.tmp'
    import os

    sourceFiles = []
    for file in os.listdir('.'):
        if os.path.splitext(file)[1] in SUFFIXES:
            sourceFiles.append(file)

    GVars.out.put('Preprocessing source files, read %s for stderr ...' % \
                  ERRORFILE)

    for file in sourceFiles:
        os.system('( cpp %(flags)s -P -C %(file)s > %(TEMPFILE)s ) 2>>' \
                  ' %(ERRORFILE)s' % locals() )
        os.rename(TEMPFILE, file)

def linkFiles(fromdir, prevSrcFileList, opts, sourceDir):
    """Link files in with right extension in fromdir to current directory.

    Note: if blah.c is in fromdir and blah.F90 is in the current directory,
    blah.F90 gets deleted. Same thing for other groups of extensions."""
    GROUPS = [['.f90', '.F90', '.f', '.c', '.F', '.C', '.inc', '.a'],
                 '.py', '.fh', '.h', '_A', '.dek', '.dat', '.out', '.int', '.csh', '.rates']
    #put extensions that aren't grouped into a one-item list (save typing)
    GROUPS = map(lambda x: (type(x)==types.ListType and [x] or [[x]])[0],
                 GROUPS) 
    EXTS = reduce(lambda x,y: x+y, GROUPS)

    files = []
    for file in os.listdir(fromdir):
        if os.path.splitext(file)[1] in EXTS:
            if opts.ioConvertBool == 1:
                newFromDir = verifyIOConvertLink(fromdir, file, opts, sourceDir)
                files.append(os.path.join(newFromDir, file))
                
            else:
                files.append(os.path.join(fromdir, file))

            
    #sort to get consistent behavior when 2 files with equivalent extensions
    #are in fromdir    
    files.sort()
    files.reverse() 
    for file in files:
        if file in prevSrcFileList:
            #FIXME not clear how this mixes with extension grouping
            GVars.out.put('found up-to-date file %s ... not linking'%file)
            continue
        outfile = os.path.split(file)[1]
        base, ext = os.path.splitext(outfile)
        for group in GROUPS:
            if ext not in group: continue
            for ext2 in group:
                if os.path.exists(base+ext2): os.remove(base+ext2)

        linkCommand(file, outfile)
        
    return files




def verifyIOConvertLink(fromDir, file, opts, sourceDir):

    if file == "checkpoint_re.F90":
        newFromDir = os.path.join(sourceDir, opts.ioConvert[0])
        
    elif file == "checkpoint_wr.F90":
        newFromDir = os.path.join(sourceDir, opts.ioConvert[1])
        
    elif file == "init_global_parms_checkpoint.F90":
        newFromDir = os.path.join(sourceDir, opts.ioConvert[0])
        
    elif file == "plotfile.F90":
        newFromDir = os.path.join(sourceDir, opts.ioConvert[1])

    else:
        newFromDir = fromDir

        
    return newFromDir   


        


def linkCommand(linkFile, outFile):
    """Function serves to link files whether portable is selected or not"""
    #FIXME make links relative
    if GVars.portable:
        shutil.copyfile(linkFile, outFile)
        shutil.copymode(linkFile, outFile)
    else:
        os.symlink(linkFile, outFile)

def getInternalLib(lib):
    """Returns string to add to link line or None if the internal lib doesn't
    exist. Raises errors if internal lib exists but is troublesome"""

    USAGE = """
    Fatal Error: setup is unable to locate the internal library %(lib)s.
    In order to have setup identify an internal library, a directory
    lib/name/object must exist, where `name' is the lowercase name of the 
    library as specified with the LIBRARY directive in the relevant Config
    file. This object directory must contain an archive file
    libname.a. If libname.a does not exist in object, setup will attempt to
    build it by calling either build.py or build.csh in lib/name/source; this
    script must ultimately place libname.a in the object dir."""

    base = string.lower(lib)
    libDir = os.path.join(GVars.nerdHomeDir, 'lib', base)
    if not os.path.isdir(libDir): return None, None

    objDir = os.path.join(libDir, 'object')
    binary = os.path.join(objDir, 'lib%s.a'%base)
    
    if not os.path.isfile(binary):
        pwd = os.getcwd()
        os.chdir(os.path.join(libDir, 'source'))
        if os.path.isfile('build.py'):
            GVars.out.put('exec\'ing lib/%s/source/build.py'%base)
            exec(open('build.py').read())
        elif os.path.isfile('build.csh'):
            GVars.out.put('running lib/%s/source/build.csh'%base)
            os.system('./build.csh')
        else:
            raise SetupError(USAGE%vars())
        os.chdir(pwd)

    if not os.path.isfile(binary):
        raise SetupError(USAGE%vars())

    libMacro = '-L../lib/%(base)s/object/ -l%(base)s'%vars()
    if os.path.isdir(os.path.join(libDir, 'include')):
        includeMacro = '-I../lib/%(base)s/include'%vars()
    else:
        includeMacro = ''

    return libMacro, includeMacro

def setRedirectFlags(makefile, buildFlag, libraries):
    """
    FIXME: proper documentation
    
    If the Makefile.h uses the mechanism but hasn't defined it for the given
    buildFlag (i.e., it has FFLAGS_OPT but not FFLAGS_TEST) we default to _OPT
    for whatever compilers are missing the right flag.

    Also, we have added support for "internal" libraries. If a LIBRARY
    requirement is not found in Makefile.h, then the directory
    nerdHomeDir/lib/name/object is searched, where name is the name of
    the LIBRARY as specified in the Config file. If that directory exists and
    contains a file named libname.a, then Makefile has that info added to
    its LIB macro. Otherwise, setup attempts to execute a file called build.csh
    in a directory nerdHomeDir/lib/name/source. This file contains commands
    for building the library and placing the library libname.a in the
    lib/name/object dir.

    Some further things to consider are adding support for multiple libraries
    within a lib directory and specifying any library dependencies.
    """
    COMPILERS = ('FFLAGS', 'CFLAGS', 'LFLAGS', 'LIB')
    DEFLTFLAG = '_OPT'

    if not os.path.isfile(makefile): text = ''
    else: text = open(makefile).read()

    #local function, returns true if the macro is defined
    haveMacro = lambda macro, text=text, re=re: \
                re.compile(r'^ *%s *='%macro, re.I+re.M).search(text)

    makefileLibs = [] #libraries defined by things like LIB_HDF4
    newDef = {}    
    for compiler in COMPILERS:
        
        newDef[compiler] = ['$(%s)'%compiler]
        for macro in [compiler+buildFlag, compiler+DEFLTFLAG]:
            if haveMacro(macro):
                newDef[compiler] = ['$(%s)'%macro]
                break
            
        for lib in libraries:
            for macro in ['%s_%s_%s'%(compiler, lib, buildFlag),
                          '%s_%s_%s'%(compiler, lib, DEFLTFLAG),
                          '%s_%s'%(compiler, lib)]:                
                if haveMacro(macro):
                    newDef[compiler].append('$(%s)'%macro)
                    if compiler=='LIB': makefileLibs.append(lib)
                    break

    #We've extracted everything we can get from the Makefile; if there are
    #some libraries we need but haven't found try to get them in lib/ directory
    for lib in libraries:
        if lib in makefileLibs: continue
        GVars.out.push()
        libMacro, includeMacro = getInternalLib(lib)
        if not libMacro:
            GVars.out.put('WARNING: A Config in your setup requires the '\
                          'library %s, but %s does not define LIB flags for '\
                          'it AND there is no lib/%s directory.' \
                          % (lib, makefile, string.lower(lib)))
        else:
            newDef['LIB'].insert(1, libMacro)
            if includeMacro:
                newDef['CFLAGS'].append(includeMacro)
                newDef['FFLAGS'].append(includeMacro)
        GVars.out.pop()
            
    out = ''
    for compiler in newDef.keys():
        if (len(newDef[compiler])==1) and \
           (newDef[compiler][0]=='$(%s)'%compiler): continue
        macros = newDef[compiler]
        #want "main" macros like LIB_OPT to be at the end of the line
        macros = macros[1:]+[macros[0]]
        out = out + '%s := %s\n' % (compiler, string.join(macros))

    return out

def parseCommandLine(opts):
    USAGE="""usage:  setup <problem-name> [options]

        problems: see setups/ directory
        options: -auto -[123]d -maxblocks=<#> -nxb=<#> -nyb=<#> -nzb=<#>
                 -portable -verbose -force [-site=<site> | -ostype=<ostype>]
                 [-debug | -test] -preprocess -objdir=<relative obj directory>
                 -with-module=<module> -io_convert=<from_iopath:to_iopath>
"""
    
    args = sys.argv[1:]
    if (not args) or (args[0] in ['-help', '-h', '--help']):
        raise SetupError(USAGE)

    opts.setupName = args[0]
    args = args[1:]

    reDim = re.compile(r'-[123]d$', re.I)
    reMaxblocks = re.compile(r'-maxblocks=([0-9]+)$', re.I)
    reNxb       = re.compile(r'-nxb=([0-9]+)$', re.I)
    reNyb       = re.compile(r'-nyb=([0-9]+)$', re.I)
    reNzb       = re.compile(r'-nzb=([0-9]+)$', re.I)
    reSites = re.compile(r'-site=(.+)$', re.I)
    reOstype = re.compile(r'-ostype=(.+)$', re.I)
    reObjdir = re.compile(r'-objdir=(.+)$', re.I)
    reWithMod = re.compile(r'-with-module=(.+)$', re.I)
    reIOConvert = re.compile(r'-io_convert=(.+)$', re.I)
    

    for arg in args:
        if   arg == '-portable': GVars.portable = 1
        elif arg == '-stack': opts.nerdStack = 1
        elif arg == '-noclobber': GVars.noClobber = 1
        elif arg == '-auto': opts.auto = 1
        elif arg == '-debug': opts.buildFlag = '_DEBUG'
        elif arg == '-test':  opts.buildFlag = '_TEST'
        elif arg == '-preprocess': opts.preprocess = 1
        elif arg == '-verbose': GVars.verbose = 1
        elif arg == '-nonpermanentguardcells': opts.npg = 1
        elif arg == '-force': opts.force = 1
        
        elif reDim.match(arg): opts.dimension = int(arg[1])
        elif reMaxblocks.match(arg):
            opts.maxblocks = int(reMaxblocks.match(arg).group(1))
        elif reNxb.match(arg):
            opts.nxb = int(reNxb.match(arg).group(1))
        elif reNyb.match(arg):
            opts.nyb = int(reNyb.match(arg).group(1))
        elif reNzb.match(arg):
            opts.nzb = int(reNzb.match(arg).group(1))
        elif reSites.match(arg):
            opts.build_site = reSites.match(arg).group(1)
        elif reOstype.match(arg):
            opts.build_os = reOstype.match(arg).group(1)
        elif reObjdir.match(arg):
            opts.objectDir = reObjdir.match(arg).group(1)
        elif reWithMod.match(arg):
            opts.withModules.append(reWithMod.match(arg).group(1))
        elif reIOConvert.match(arg):
            list = string.split(reIOConvert.match(arg).group(1), ":")
            if len(list) != 2 :
                raise SetupError('%s\ninvalid io_convert option: %s'%(USAGE, arg))
            else:
                opts.ioConvert.append(list[0])
                opts.ioConvert.append(list[1])
                opts.ioConvertBool = 1
                opts.withModules.append(list[0])
                opts.withModules.append(list[1])

        else:
            raise SetupError('%s\ninvalid option: %s'%(USAGE, arg))

# I believe these are redundant with physicaldata defaults
# consider removing
    if opts.maxblocks==None: #numbers from physicaldata.fh
        if opts.dimension==3:
            opts.maxblocks = 200            
        else:
            opts.maxblocks = 1000

    if opts.dimension < 3:
        if opts.nzb != None:
            raise SetupError("Must not specify nzb for dimensionality < 3d")
    if opts.dimension < 2:
        if opts.nyb != None:
            raise SetupError("Must not specify nyb for dimensionality < 2d")

    
    if opts.nzb == None:
        if opts.dimension > 2:
            opts.nzb = 8
        else:
            opts.nzb = 1

    if opts.nyb == None:
        if opts.dimension > 1:
            opts.nyb = 8
        else:
            opts.nyb = 1

    if opts.nxb == None: #numbers from physicaldata.F90
        opts.nxb = 8



    if opts.force and opts.auto:
        raise SetupError('-force and -auto are mutually exclusive')

    if opts.nerdStack:
        opts.defines.append('-DFLASH_STACK')
    
    opts.defines.append('-DN_DIM=%d'%opts.dimension)
    opts.defines.append('-DMAXBLOCKS=%d'%opts.maxblocks)

    opts.defines.append('-DNXB=%d'%opts.nxb)
    opts.defines.append('-DNYB=%d'%opts.nyb)
    opts.defines.append('-DNZB=%d'%opts.nzb)
    
def initVars(opts, GVars):
    opts.dimension = 2
    opts.defines = []
    opts.maxblocks = None
    opts.nxb       = None
    opts.nyb       = None
    opts.nzb       = None
    opts.build_site = None
    opts.build_os = None
    opts.auto = 0
    opts.preprocess = 0
    opts.setupName = None
    opts.objectDir = 'object'
    opts.buildFlag = '_OPT' #other options are '_DEBUG' and '_TEST'
    opts.npg = 0
    opts.withModules = []
    opts.ioConvert = []
    opts.ioConvertBool = 0
    opts.nerdStack = 0
    opts.force = 0

    #GVars is a repository for global variables.
    GVars.out = IndentedOutput()
    GVars.portable = 0
    GVars.verbose = 0
    GVars.report = 0
    GVars.noClobber = 0

def getOSType(prototypesDir):
    ostype = string.lower(sys.platform)
    if '-' in ostype:
        ostype = ostype[:string.find(ostype, '-')]
    for proto in os.listdir(prototypesDir):
        if string.count(ostype, string.lower(proto)):
            return proto
    return ostype

def getHostName(sitesDir):
    hostname = socket.gethostbyaddr(socket.gethostname())[0]
    GVars.out.put('checking sites Aliases file')
    GVars.out.push()
    try:
        aliasLines = open(os.path.join(sitesDir, 'Aliases')).readlines()
        for line in aliasLines:
            line = stripComments(line, '#')
            line = string.strip(line)
            if line == '':
                continue
            try:
                (site, regex) = string.split(line)
                if re.match(regex, hostname) != None:
                    hostname = site
                    break
            except ValueError: 
                GVars.out.put("bad Aliases file line '%s'" % string.strip(line))
    except IOError:
        GVars.out.put("couldn't open sites Aliases file")
    GVars.out.pop()
            
    for site in os.listdir(sitesDir):
        if string.count(hostname, site):
            hostname = site
    return hostname

def determineMachine(opts, sourceDir):
    """Returns directory of proper machine to use"""
    GVars.out.put('checking for needed files and directories')
    GVars.out.push()
    
    siteDir = os.path.join(sourceDir, 'sites')
    systemsDir = os.path.join(sourceDir,'sites', 'Prototypes')
    ostype = getOSType(systemsDir)
    hostname = getHostName(siteDir)
    
    if opts.build_site:
        machDir = os.path.join(siteDir, opts.build_site)
        if os.path.isdir(machDir):
            GVars.out.put('using site directory for site '+opts.build_site)
                          
        else:
            raise SetupError('fatal:  could not find site directory for '\
                             'site %s'%opts.build_site)
    

    elif opts.build_os:
        machDir = os.path.join(systemsDir, opts.build_os)
        if os.path.isdir(machDir):
            GVars.out.put('using prototype directory for ostype '+ \
                          opts.build_os)
                          
        else:
            raise SetupError('fatal:  could not find prototype directory for '
                             'ostype ' + opts.build_os)

    else:
        machDir = os.path.join(siteDir, hostname)
        if os.path.isdir(machDir):
            GVars.out.put('using site directory for site '+hostname)
        else:
            machDir = os.path.join(systemsDir, ostype)
            if os.path.isdir(machDir):
                GVars.out.put('site directory for site '+hostname+\
                              ' not found;')
                GVars.out.put('using prototype '+ostype)
            else:
                raise SetupError('fatal:  could not find site for prototype'\
                                 ' directory!\n'
                                 '         specify site or ostype, or else '\
                                 'create a directory for your site\n\n'
                                 '         site    = %s'
                                 '\n         ostype  = %s'%(hostname,ostype))

    GVars.out.pop()
    return machDir

def getPrevSrcFileList(dir):
    out = []
    if GVars.noClobber:
        try: out = open(os.path.join(dir,'setup_src')).read()            
        except: raise SetupError('Can\'t read setup_src file... run without'\
                                 ' -noclobber flag')
        out = string.split(out)
    return out

def cleanObjectDir(dir):
    #keep files with the following extensions if -noclobber is used
    NOCLOBBEREXT = ['.so', '.a', '.o', '.mod', '.F90', '.c', '.fh', '.int',
                    '.py'] 

    if not os.path.isdir(dir):
        os.mkdir(dir)

    if not GVars.noClobber: #delete all files
        GVars.out.put('removing old links in build directory %s'%dir)
        for file in os.listdir(dir):
            if not os.path.isdir(os.path.join(dir, file)):
                os.remove(os.path.join(dir, file))
    else:
        #need to tell user something?
        for file in os.listdir(dir):
            if not (os.path.isdir(os.path.join(dir, file)) or \
                    (os.path.splitext(file)[1] in NOCLOBBEREXT)):
                os.remove(os.path.join(dir, file))

def createMakefiles(modules, sourceDir):
    """ Makefiles: one for each toplevel Module. Makefiles for submodules get
    appended to the top one."""
    TEMPLATE="""#\tMakefile generated by setup for module %(module)s.  This Makefile is
#\tempty; if make complains about unresolved references at link time, you
#\tneed to create stub routines for this module and create a Makefile
#\twhich sets the value of the macro $(%(module)s) equal to the list
#\tof object files containing your stub routines.  There should be a stub
#\troutine for every routine which is called outside the module, to be
#\tused in case the module is not included (or in case the included
#\tsub-modules of this module do not define/override some routines).

#\tFor example, if your stub routines reside in files named stub1.F,
#\tstub2.F, and stub3.F in the %(module)s directory, your Makefile should
#\tcontain the line
#\t\t%(module)s = stub1.o stub2.o stub3.o

#\tFor sub-modules which redefine these routines (and give the files the
#\tsame names), no additional Makefile is required.  If a sub-module
#\tnamed \"urp\" adds another file named myfile.F, then in %(module)s/urp
#\tcreate a Makefile containing

#\t\t%(module)s += myfile.o

%(module)s =
"""

    for module in modules:
        base = module.name
        while 1:
            if not os.path.split(base)[0]: break
            base = os.path.split(base)[0]

        source = os.path.join(sourceDir, module.name, "Makefile")
        target = 'Makefile.'+base
        
        if os.path.isfile(source):
            file = open(target, 'a')
            file.write(open(source).read())
            file.close()
        elif module==base:
            file = open(target, 'w')
            file.write(TEMPLATE% vars())
            file.close()

########################### START SCRIPT #####################################
def main():
    opts = EmptyClass()
    initVars(opts, GVars)

    # the [:-4] was added here because setup.py now resides in FLASH_HOME/bin
    # to remove the /bin, we just strip off the last 4 characters.
    # this is not a very readable or robust way to do it, but it's good enough
    # for now. Should improve later
    GVars.nerdHomeDir = (os.path.abspath(os.path.dirname(sys.argv[0])))[:-4]

    os.chdir(GVars.nerdHomeDir)
    
    sourceDir = os.path.join(GVars.nerdHomeDir, 'source')
    setupsDir = os.path.join(GVars.nerdHomeDir, 'setups')

    parseCommandLine(opts)
    machDir = determineMachine(opts, sourceDir)

    MODULESFILE = 'Modules'

    if opts.auto:
        GVars.out.put('generating default %s file'%MODULESFILE)
        generateModulesfile(MODULESFILE, opts)

    prevSrcFileList = getPrevSrcFileList(opts.objectDir)
    cleanObjectDir(opts.objectDir)
            
    ############## SWITCHING TO SOURCE DIR ############################
    os.chdir(sourceDir)

    setupModule = NerdModule(os.path.join('..', 'setups', opts.setupName))

    try:
        modules = []
        modules = modules + \
                  readInputModulesFile(os.path.join(GVars.nerdHomeDir,
                                                    MODULESFILE), opts)
    except SetupError, inst:
        #if -force, allow for nonexistent Modules file.
        if not (len(inst.args)==2 and opts.force):
            raise inst

    if opts.force:
        GVars.out.put('Using modules directly required by %s'%opts.setupName)
        modules = modules + \
                  expandRequiredModules([setupModule])
        modules.remove(setupModule)
        modules = removeParentModules(modules)

    GVars.out.put('checking for default sub-modules in included modules')
    modules = expandDefaultModules(modules[:])
    modules = expandParentModules(modules[:])

    GVars.out.put('checking that no mutually exclusive sub-modules '\
                  'are included together')
    checkExclusivity(modules)
    checkConflicts(modules)
    
    if not opts.force:
        GVars.out.put('looking for paths of non-included modules')
        modules = addTopModules(modules) #Ignores Config files
    modules.sort()
    modules.append(setupModule)
    if not opts.force: #Not sure if we want this or not
        GVars.out.put('checking requirements')
        checkRequirements(modules[:])
    configInfo = ModuleUnion(modules[:])
    
    ############################### CHANGE TO OBJECT DIR ###################
    os.chdir(GVars.nerdHomeDir)
    os.chdir(opts.objectDir)
    outputParameterInfo(modules[:])

    #modules is sorted so that subdirectories will overwrite parents' files
    file = open("setup_src", 'aw')
    for module in modules:
        fileList = linkFiles(os.path.join(sourceDir, module.name),
                             prevSrcFileList, opts, sourceDir)
        for filename in fileList:
          file.write(filename + "\n")
    file.close()
    linkFiles(os.path.join(sourceDir, 'sites'), prevSrcFileList, opts, sourceDir)
    linkFiles(machDir, prevSrcFileList, opts, sourceDir) 

    #  Copy in nerd.par
    if os.path.isfile(os.path.join(setupsDir, opts.setupName, 'nerd.par')):
        shutil.copy(os.path.join(setupsDir, opts.setupName, 'nerd.par'), '.')

    test_src = os.path.join(GVars.nerdHomeDir, 'tools', 'scripts', 'testing',
                            'precision_test', 'precision_test.F90')    
    if os.path.isfile(test_src):
        shutil.copy(test_src, '.')

    GVars.out.put('creating Makefiles for all modules')
    createMakefiles(modules[:-1], sourceDir) #skipping setup module
    #FIXME merge with createMakefiles
    if os.path.isfile(os.path.join('..','setups',opts.setupName,'Makefile')):
        GVars.out.put('creating Makefile link to problem setup directory')
        linkCommand(os.path.join('..', 'setups', opts.setupName, 'Makefile'),
                    'Makefile.'+opts.setupName)

    if opts.nerdStack:
        applyNerdStack()

    GVars.out.put('generating buildstamp generator')
    generateBuildstampGenerator()

    GVars.out.put('copying release accessor function Makefile')
    shutil.copy(os.path.join(GVars.nerdHomeDir, 'bin/make_release'), '.')

    GVars.out.put('copying buildstats accessor function Makefile')
    shutil.copy(os.path.join(GVars.nerdHomeDir, 'bin/make_bstats'), '.')

    GVars.out.put('copying nerdModules accessor function Makefile')
    shutil.copy(os.path.join(GVars.nerdHomeDir, 'bin/make_nerdModules'), '.')

    shutil.copy(os.path.join(GVars.nerdHomeDir, 'bin/resetup'), '.')

    GVars.out.put('generating Makefile')
    generateMakefile(configInfo, opts, machDir)
    
    generateDbaseDefines(configInfo, opts)
    
    if opts.preprocess:
        runPreprocessor(string.join(opts.defines))

    dumpSetupInfo(modules)    
    os.chdir(GVars.nerdHomeDir)
    generateParameterCommentList(modules)
#    printMemUsageGuess(configInfo, opts)
    GVars.out.put('SUCCESS')

########################### END SCRIPT #######################################
if __name__=='__main__':
    GVars = EmptyClass() #global vars, to be eliminated little by little
    try:
        main()
    except SetupError, inst:
        if inst.args: print inst.args[0]
        sys.exit(1)
    except KeyboardInterrupt:
        print '\nuser abort'
        sys.exit(1)
    except:
        print '\nA setup internal error has occured, if possible please email the following\ndebugging info to nerd-bugs@nerd.uchicago.edu'
        print 'Arguments:', sys.argv
        print 'Version:', sys.version
        print 'Platform:', sys.platform
        #FIXME print out machine/python info too.
        raise

